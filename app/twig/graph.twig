{% extends "page.twig" %}

{% block title %}{{ 'graph_page.title'|trans }}{% endblock %}
{% set is_wide_page = true %}

{% block head %}
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.33.1/dist/cytoscape.min.js"></script>
    <style>
        .graph-stage {
            position: relative;
        }
        .graph-search-control {
            position: relative;
            width: 100%;
        }
        #node-search-suggestions {
            position: absolute;
            top: calc(100% + 2px);
            left: 0;
            right: 0;
            z-index: 45;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: #ffffff;
            box-shadow: 0 8px 20px rgba(15, 23, 42, 0.14);
            overflow: hidden;
            max-height: 17rem;
            overflow-y: auto;
        }
        .graph-search-item {
            padding: 0.45rem 0.55rem;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
        }
        .graph-search-item:last-child {
            border-bottom: none;
        }
        .graph-search-item:hover {
            background: #eff6ff;
        }
        .graph-search-item-title {
            font-size: 0.76rem;
            color: #0f172a;
            line-height: 1.2;
            margin-bottom: 0.1rem;
        }
        .graph-search-item-meta {
            font-size: 0.66rem;
            color: #475569;
            line-height: 1.2;
            font-family: monospace;
            word-break: break-word;
        }
        .graph-search-item-empty {
            padding: 0.45rem 0.55rem;
            font-size: 0.74rem;
            color: #64748b;
        }
        #cy {
            width: 100%;
            height: 80vh;
            min-height: 560px;
            border: 1px solid #dbdbdb;
            border-radius: 6px;
            background: #f8fafc;
        }
        #graph-tooltip {
            position: absolute;
            z-index: 30;
            display: none;
            max-width: 22rem;
            padding: 0.4rem 0.55rem;
            border-radius: 4px;
            background: rgba(17, 24, 39, 0.92);
            color: #f9fafb;
            font-size: 0.7rem;
            line-height: 1.2;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.22);
            word-break: break-word;
        }
        .graph-summary-list li {
            display: flex;
            justify-content: space-between;
            gap: 0.75rem;
            margin-bottom: 0.35rem;
        }
        .graph-summary-list span:last-child {
            font-family: monospace;
            white-space: nowrap;
        }
        #selection-details p {
            margin-bottom: 0.5rem;
            word-break: break-word;
        }
        #top-incoming li {
            display: flex;
            justify-content: space-between;
            gap: 0.75rem;
        }
        .graph-controls-box .field + .field {
            margin-top: 0.75rem;
        }
        .graph-filters-box .field + .field {
            margin-top: 0.85rem;
        }
        .graph-filters-box .checkbox {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }
        .graph-filters-box .select.is-multiple select {
            width: 100%;
        }
        .graph-filter-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem 0.75rem;
            margin-top: 0.45rem;
        }
        .graph-filter-action-link {
            display: inline-block;
            font-size: 0.72rem;
            color: #334155;
            text-decoration: none;
            border-bottom: 1px dotted #94a3b8;
            line-height: 1.2;
            cursor: pointer;
        }
        .graph-filter-action-link:hover {
            color: #1d4ed8;
            border-bottom-color: #1d4ed8;
        }
        @media (max-width: 1023px) {
            #cy {
                height: 68vh;
                min-height: 420px;
            }
        }
    </style>
{% endblock %}

{% block breadcrumbs %}
    <li><a href="/" aria-current="page">{{ 'common.short_name'|trans }}</a></li>
    <li class="is-active"><a href="/graph" aria-current="page">{{ 'graph_page.title'|trans }}</a></li>
{% endblock %}

{% block content %}
    <h1 class="title">{{ 'graph_page.title'|trans }}</h1>
    <p class="block">{{ 'graph_page.description'|trans }}</p>

    <div class="box graph-controls-box">
        <div class="columns is-variable is-3 mb-1">
            <div class="column is-6-desktop is-12-tablet">
                <div class="field">
                    <label class="label is-size-7 mb-1">{{ 'graph_page.controls.layout'|trans }}</label>
                    <div class="field has-addons">
                        <div class="control is-expanded">
                            <div class="select is-small is-fullwidth">
                                <select id="layout-select">
                                    <option value="cose">CoSE</option>
                                    <option value="concentric">Concentric</option>
                                    <option value="breadthfirst">Breadthfirst</option>
                                    <option value="circle">Circle</option>
                                </select>
                            </div>
                        </div>
                        <div class="control">
                            <button id="layout-run" class="button is-small is-link is-light" type="button">
                                {{ 'graph_page.controls.run_layout'|trans }}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="column is-6-desktop is-12-tablet">
                <div class="field graph-search-control">
                    <label class="label is-size-7 mb-1">{{ 'graph_page.controls.find_node'|trans }}</label>
                    <input
                        id="node-search-input"
                        class="input is-small"
                        type="text"
                        autocomplete="off"
                        placeholder="{{ 'graph_page.controls.find_placeholder'|trans }}"
                    >
                    <div id="node-search-suggestions" class="is-hidden"></div>
                </div>
            </div>
        </div>
        <p id="status-text" class="is-size-7 has-text-grey mb-2">{{ 'graph_page.loading'|trans }}</p>
        <div class="graph-stage">
            <div id="graph-tooltip"></div>
            <div id="cy"></div>
        </div>
    </div>

    <div class="columns is-variable is-4">
        <div class="column is-4">
            <div class="box">
                <h2 class="title is-6">{{ 'graph_page.details.title'|trans }}</h2>
                <div id="selection-details" class="is-size-7 has-text-grey">
                    {{ 'graph_page.details.empty'|trans }}
                </div>
            </div>
        </div>
        <div class="column is-4">
            <div class="box graph-filters-box">
                <h2 class="title is-6 mb-3">{{ 'graph_page.filters.title'|trans }}</h2>
                <div class="field">
                    <label class="label is-size-7 mb-1">{{ 'graph_page.controls.min_incoming'|trans }}</label>
                    <input id="min-incoming" class="input is-small" type="number" min="0" value="0">
                </div>
                <div class="field">
                    <label class="checkbox is-size-7">
                        <input id="hide-isolated" type="checkbox">
                        {{ 'graph_page.controls.hide_isolated'|trans }}
                    </label>
                </div>
                <div class="field">
                    <label class="checkbox is-size-7">
                        <input id="only-mtla" type="checkbox">
                        {{ 'graph_page.filters.only_mtla'|trans }}
                    </label>
                </div>
                <div class="field">
                    <label class="label is-size-7 mb-1">{{ 'graph_page.filters.link_types'|trans }}</label>
                    <div class="select is-multiple is-small is-fullwidth">
                        <select id="tag-types-select" multiple size="10"></select>
                    </div>
                    <div class="graph-filter-actions">
                        <a class="graph-filter-action-link" data-tag-filter-action="without-signer">{{ 'graph_page.filters.without_signer'|trans }}</a>
                        <a class="graph-filter-action-link" data-tag-filter-action="only-known">{{ 'graph_page.filters.only_known'|trans }}</a>
                        <a class="graph-filter-action-link" data-tag-filter-action="only-standard">{{ 'graph_page.filters.only_standard'|trans }}</a>
                        <a class="graph-filter-action-link" data-tag-filter-action="families">{{ 'graph_page.filters.families'|trans }}</a>
                        <a class="graph-filter-action-link" data-tag-filter-action="ownership-rights">{{ 'graph_page.filters.ownership_rights'|trans }}</a>
                    </div>
                </div>
                <div class="field">
                    <button id="filters-apply" class="button is-primary is-small is-fullwidth" type="button">
                        {{ 'graph_page.filters.apply'|trans }}
                    </button>
                </div>
            </div>
        </div>
        <div class="column is-4">
            <div class="box">
                <h2 class="title is-6">{{ 'graph_page.summary.title'|trans }}</h2>
                <ul class="graph-summary-list is-size-7">
                    <li><span>{{ 'graph_page.summary.created_at'|trans }}</span><span id="summary-created-at">-</span></li>
                    <li><span>{{ 'graph_page.summary.total_accounts'|trans }}</span><span id="summary-total-accounts">-</span></li>
                    <li><span>{{ 'graph_page.summary.total_nodes'|trans }}</span><span id="summary-total-nodes">-</span></li>
                    <li><span>{{ 'graph_page.summary.total_links'|trans }}</span><span id="summary-total-links">-</span></li>
                    <li><span>{{ 'graph_page.summary.pair_links'|trans }}</span><span id="summary-pair-links">-</span></li>
                    <li><span>{{ 'graph_page.summary.clusters'|trans }}</span><span id="summary-clusters">-</span></li>
                    <li><span>{{ 'graph_page.summary.largest_cluster'|trans }}</span><span id="summary-largest-cluster">-</span></li>
                    <li><span>{{ 'graph_page.summary.visible_accounts'|trans }}</span><span id="summary-visible-nodes">-</span></li>
                    <li><span>{{ 'graph_page.summary.visible_links'|trans }}</span><span id="summary-visible-edges">-</span></li>
                </ul>
                <h3 class="title is-7 mt-4 mb-2">{{ 'graph_page.top_incoming'|trans }}</h3>
                <ol id="top-incoming" class="is-size-7"></ol>
            </div>
        </div>
    </div>

    <script>
        (function () {
            const stellarIdRe = /^G[A-Z2-7]{55}$/;
            const layoutSelect = document.getElementById('layout-select');
            const layoutRun = document.getElementById('layout-run');
            const minIncomingInput = document.getElementById('min-incoming');
            const hideIsolatedInput = document.getElementById('hide-isolated');
            const onlyMtlaInput = document.getElementById('only-mtla');
            const tagTypesSelect = document.getElementById('tag-types-select');
            const filtersApplyButton = document.getElementById('filters-apply');
            const statusText = document.getElementById('status-text');
            const selectionDetails = document.getElementById('selection-details');
            const topIncomingList = document.getElementById('top-incoming');
            const tooltip = document.getElementById('graph-tooltip');
            const searchInput = document.getElementById('node-search-input');
            const searchSuggestions = document.getElementById('node-search-suggestions');
            const tagFilterActionLinks = Array.from(document.querySelectorAll('[data-tag-filter-action]'));
            const urlQuery = new URLSearchParams(window.location.search);
            const queryNodeIdRaw = urlQuery.get("id") || "";
            const queryNodeId = queryNodeIdRaw.trim().toUpperCase();
            const pinnedNodeId = stellarIdRe.test(queryNodeId) ? queryNodeId : "";
            const queryCentricRaw = (urlQuery.get("centric") || "").trim().toLowerCase();
            const centricMode = Boolean(pinnedNodeId) && queryCentricRaw === "yes";
            const queryOnlyMtlaRaw = (urlQuery.get("only_mtla") || "").trim().toLowerCase();
            const queryOnlyMtla = queryOnlyMtlaRaw === "yes";

            const i18n = {
                loading: "{{ 'graph_page.loading'|trans|e('js') }}",
                loadError: "{{ 'graph_page.load_error'|trans|e('js') }}",
                detailsEmpty: "{{ 'graph_page.details.empty'|trans|e('js') }}",
                nodeIncoming: "{{ 'graph_page.node.incoming'|trans|e('js') }}",
                nodeOutgoing: "{{ 'graph_page.node.outgoing'|trans|e('js') }}",
                nodeCluster: "{{ 'graph_page.node.cluster'|trans|e('js') }}",
                nodeOpenAccount: "{{ 'graph_page.node.open_account'|trans|e('js') }}",
                nodeLink: "{{ 'graph_page.node.node_link'|trans|e('js') }}",
                edgeSource: "{{ 'graph_page.edge.source'|trans|e('js') }}",
                edgeTarget: "{{ 'graph_page.edge.target'|trans|e('js') }}",
                edgeCount: "{{ 'graph_page.edge.count'|trans|e('js') }}",
                edgeTags: "{{ 'graph_page.edge.tags'|trans|e('js') }}",
                searchNoMatches: "{{ 'graph_page.controls.find_no_matches'|trans|e('js') }}",
                unknownTags: "{{ 'graph_page.filters.unknown_tags'|trans|e('js') }}"
            };

            const UNKNOWN_TAG_OPTION = "__unknown_tags__";
            const TAG_OPTION_PREFIX = "tag:";
            const TAG_PRESET_FAMILIES = ["OneFamily", "Spouse", "Ward", "Guardian", "Love"];
            const TAG_PRESET_OWNERSHIP = ["OwnershipFull", "OwnerMajority", "Owner", "OwnerMinority", "OwnershipMajority"];
            const SIGNER_TAG = "Signer";

            let cy = null;
            let searchIndex = [];
            let sourceGraphData = null;
            let sourceContactLabels = {};
            let sourceKnownLinks = {};

            function showTooltip(node, renderedPosition) {
                tooltip.innerHTML =
                    "<strong>" + escapeHtml(node.data("displayName")) + "</strong><br>" +
                    "<code>" + escapeHtml(node.id()) + "</code>";
                tooltip.style.display = "block";
                const stage = tooltip.parentElement;
                const stageWidth = stage ? stage.clientWidth : 0;
                const stageHeight = stage ? stage.clientHeight : 0;
                let left = renderedPosition.x + 12;
                let top = renderedPosition.y + 12;
                if (stageWidth > 0) {
                    left = Math.min(left, stageWidth - 260);
                }
                if (stageHeight > 0) {
                    top = Math.min(top, stageHeight - 60);
                }
                tooltip.style.left = Math.max(8, left) + "px";
                tooltip.style.top = Math.max(8, top) + "px";
            }

            function hideTooltip() {
                tooltip.style.display = "none";
            }

            function shortAccount(id) {
                return id.slice(0, 2) + ".." + id.slice(-6);
            }

            function escapeHtml(value) {
                return String(value)
                    .replaceAll("&", "&amp;")
                    .replaceAll("<", "&lt;")
                    .replaceAll(">", "&gt;")
                    .replaceAll("\"", "&quot;")
                    .replaceAll("'", "&#039;");
            }

            function renderDate(value) {
                if (!value) {
                    return "-";
                }
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) {
                    return value;
                }
                return date.toLocaleString();
            }

            function buildNodeGraphUrl(accountId) {
                const params = new URLSearchParams(window.location.search);
                params.set("id", accountId);
                return "/graph?" + params.toString();
            }

            async function fetchGraphJson() {
                const urls = ["/json", "/bsn.json"];
                let lastError = null;
                for (const url of urls) {
                    try {
                        const response = await fetch(url, {cache: "no-store"});
                        if (!response.ok) {
                            throw new Error("HTTP " + response.status);
                        }
                        return await response.json();
                    } catch (error) {
                        lastError = error;
                    }
                }
                throw lastError || new Error("Failed to load data");
            }

            function normalizeContactLabel(value) {
                if (value === null || value === undefined) {
                    return "";
                }
                const label = String(value).trim();
                if (!label || label === "0") {
                    return "";
                }
                return label;
            }

            async function fetchContactLabels() {
                try {
                    const response = await fetch("/contacts?format=json", {cache: "no-store"});
                    if (response.status === 401 || response.status === 403) {
                        console.log("Contacts JSON is unavailable for current user. HTTP:", response.status);
                        return {};
                    }
                    if (!response.ok) {
                        console.log("Contacts JSON request failed. HTTP:", response.status);
                        return {};
                    }
                    const data = await response.json();
                    const contacts = data && typeof data === "object" ? data.contacts : null;
                    if (!contacts || typeof contacts !== "object") {
                        return {};
                    }

                    const labels = {};
                    for (const [accountId, item] of Object.entries(contacts)) {
                        if (!stellarIdRe.test(accountId)) {
                            continue;
                        }
                        const label = normalizeContactLabel(item && item.label);
                        if (!label) {
                            continue;
                        }
                        labels[accountId] = label;
                    }
                    return labels;
                } catch (error) {
                    console.log("Contacts JSON request failed:", error);
                    return {};
                }
            }

            async function fetchKnownLinks() {
                try {
                    const response = await fetch("/known_tags.json", {cache: "no-store"});
                    if (!response.ok) {
                        console.log("Known tags request failed. HTTP:", response.status);
                        return {};
                    }
                    const data = await response.json();
                    const links = data && typeof data === "object" ? data.links : null;
                    if (!links || typeof links !== "object") {
                        return {};
                    }
                    return links;
                } catch (error) {
                    console.log("Known tags request failed:", error);
                    return {};
                }
            }

            function tagOptionValue(tagName) {
                return TAG_OPTION_PREFIX + tagName;
            }

            function tagNameFromOptionValue(optionValue) {
                if (typeof optionValue !== "string") {
                    return "";
                }
                if (!optionValue.startsWith(TAG_OPTION_PREFIX)) {
                    return "";
                }
                return optionValue.slice(TAG_OPTION_PREFIX.length);
            }

            function isKnownTagName(tagName, knownLinks) {
                return tagName === SIGNER_TAG || Object.prototype.hasOwnProperty.call(knownLinks, tagName);
            }

            function collectUsedTags(accounts) {
                const used = new Set();
                for (const accountData of Object.values(accounts || {})) {
                    const tags = accountData && accountData.tags ? accountData.tags : {};
                    for (const tagName of Object.keys(tags)) {
                        used.add(tagName);
                    }
                }
                return used;
            }

            function initializeTagTypeOptions(accounts, knownLinks) {
                if (!tagTypesSelect) {
                    return;
                }
                const usedTags = collectUsedTags(accounts);
                const knownUsed = Array.from(usedTags).filter((tagName) => isKnownTagName(tagName, knownLinks));
                knownUsed.sort((a, b) => a.localeCompare(b));

                const options = [];
                for (const tagName of knownUsed) {
                    options.push({
                        value: tagOptionValue(tagName),
                        label: tagName,
                        selected: true
                    });
                }
                options.push({
                    value: UNKNOWN_TAG_OPTION,
                    label: i18n.unknownTags,
                    selected: true
                });

                tagTypesSelect.innerHTML = "";
                for (const optionData of options) {
                    const option = document.createElement("option");
                    option.value = optionData.value;
                    option.textContent = optionData.label;
                    option.selected = Boolean(optionData.selected);
                    tagTypesSelect.appendChild(option);
                }
            }

            function getSelectedTagOptions() {
                const selected = new Set();
                if (!tagTypesSelect) {
                    return selected;
                }
                for (const option of Array.from(tagTypesSelect.options)) {
                    if (option.selected) {
                        selected.add(option.value);
                    }
                }
                return selected;
            }

            function setTagSelectionByPredicate(predicate) {
                if (!tagTypesSelect) {
                    return;
                }
                for (const option of Array.from(tagTypesSelect.options)) {
                    const tagName = tagNameFromOptionValue(option.value);
                    option.selected = Boolean(predicate(option.value, tagName));
                }
            }

            function applyTagFilterPreset(action) {
                if (!tagTypesSelect) {
                    return;
                }

                if (action === "without-signer") {
                    setTagSelectionByPredicate(function (optionValue, tagName) {
                        return optionValue === UNKNOWN_TAG_OPTION || tagName !== SIGNER_TAG;
                    });
                    return;
                }

                if (action === "only-known") {
                    setTagSelectionByPredicate(function (optionValue) {
                        return optionValue !== UNKNOWN_TAG_OPTION;
                    });
                    return;
                }

                if (action === "only-standard") {
                    setTagSelectionByPredicate(function (optionValue, tagName) {
                        if (optionValue === UNKNOWN_TAG_OPTION) {
                            return false;
                        }
                        const tagMeta = sourceKnownLinks[tagName] || {};
                        return Boolean(tagMeta.standard);
                    });
                    return;
                }

                if (action === "families") {
                    const familySet = new Set(TAG_PRESET_FAMILIES);
                    setTagSelectionByPredicate(function (optionValue, tagName) {
                        return optionValue !== UNKNOWN_TAG_OPTION && familySet.has(tagName);
                    });
                    return;
                }

                if (action === "ownership-rights") {
                    const ownershipSet = new Set(TAG_PRESET_OWNERSHIP);
                    setTagSelectionByPredicate(function (optionValue, tagName) {
                        return optionValue !== UNKNOWN_TAG_OPTION && ownershipSet.has(tagName);
                    });
                }
            }

            function labelFromName(name, id) {
                if (name) {
                    return name.length > 24 ? name.slice(0, 21) + "..." : name;
                }
                return shortAccount(id);
            }

            function hasMtlaBalanceCode(balances, code) {
                if (!balances || typeof balances !== "object") {
                    return false;
                }
                return code in balances;
            }

            function collectMtlaAccounts(accounts, maxDepth) {
                const ownersByAccount = new Map();
                const ownershipByAccount = new Map();
                const directMtlaMembers = new Set();

                for (const [accountId, accountData] of Object.entries(accounts)) {
                    const balances = accountData && accountData.balances ? accountData.balances : {};
                    if (hasMtlaBalanceCode(balances, "MTLAP") || hasMtlaBalanceCode(balances, "MTLAC")) {
                        directMtlaMembers.add(accountId);
                    }

                    const tags = accountData && accountData.tags ? accountData.tags : {};
                    const ownerTargets = Array.isArray(tags.Owner) ? tags.Owner.filter((value) => typeof value === "string") : [];
                    const ownershipTargets = Array.isArray(tags.OwnershipFull) ? tags.OwnershipFull.filter((value) => typeof value === "string") : [];
                    ownersByAccount.set(accountId, new Set(ownerTargets));
                    ownershipByAccount.set(accountId, new Set(ownershipTargets));
                }

                const ownershipAdjacency = new Map();
                const addAdjacency = function (from, to) {
                    if (!ownershipAdjacency.has(from)) {
                        ownershipAdjacency.set(from, new Set());
                    }
                    ownershipAdjacency.get(from).add(to);
                };

                for (const [sourceId, ownershipTargets] of ownershipByAccount.entries()) {
                    for (const targetId of ownershipTargets) {
                        if (!accounts[targetId]) {
                            continue;
                        }
                        const reverseOwners = ownersByAccount.get(targetId);
                        if (!reverseOwners || !reverseOwners.has(sourceId)) {
                            continue;
                        }
                        addAdjacency(sourceId, targetId);
                        addAdjacency(targetId, sourceId);
                    }
                }

                const result = new Set(directMtlaMembers);
                const queue = [];
                for (const accountId of directMtlaMembers) {
                    queue.push({id: accountId, depth: 0});
                }

                while (queue.length) {
                    const current = queue.shift();
                    if (!current || current.depth >= maxDepth) {
                        continue;
                    }
                    const neighbors = ownershipAdjacency.get(current.id);
                    if (!neighbors) {
                        continue;
                    }
                    for (const neighborId of neighbors) {
                        if (result.has(neighborId)) {
                            continue;
                        }
                        result.add(neighborId);
                        queue.push({id: neighborId, depth: current.depth + 1});
                    }
                }

                return result;
            }

            function getFilterOptions() {
                return {
                    minIncoming: Math.max(0, parseInt(minIncomingInput.value || "0", 10) || 0),
                    hideIsolated: Boolean(hideIsolatedInput.checked),
                    onlyMtla: Boolean(onlyMtlaInput && onlyMtlaInput.checked),
                    selectedTagOptions: getSelectedTagOptions()
                };
            }

            function buildGraph(data, contactLabels, knownLinks, filterOptions) {
                const accounts = data.accounts || {};
                const allowedMtlaAccounts = filterOptions.onlyMtla ? collectMtlaAccounts(accounts, 3) : null;
                const selectedTagOptions = filterOptions.selectedTagOptions || new Set();
                const nodesMap = new Map();
                const incomingRaw = new Map();
                const outgoingRaw = new Map();
                const edgeMap = new Map();

                for (const [accountId, accountData] of Object.entries(accounts)) {
                    if (allowedMtlaAccounts && !allowedMtlaAccounts.has(accountId)) {
                        continue;
                    }
                    const profile = accountData && accountData.profile ? accountData.profile : {};
                    const names = Array.isArray(profile.Name) ? profile.Name : [];
                    const bsnName = names.length ? String(names[0]).trim() : "";
                    const contactLabel = contactLabels[accountId] || "";
                    const effectiveName = contactLabel || bsnName;
                    nodesMap.set(accountId, {
                        id: accountId,
                        bsnName: bsnName,
                        contactLabel: contactLabel,
                        name: effectiveName,
                        label: labelFromName(effectiveName, accountId)
                    });
                    incomingRaw.set(accountId, 0);
                    outgoingRaw.set(accountId, 0);
                }

                let rawLinks = 0;
                for (const [sourceId, accountData] of Object.entries(accounts)) {
                    if (allowedMtlaAccounts && !allowedMtlaAccounts.has(sourceId)) {
                        continue;
                    }
                    const tags = accountData && accountData.tags ? accountData.tags : {};
                    for (const [tagName, targets] of Object.entries(tags)) {
                        const isKnownTag = isKnownTagName(tagName, knownLinks);
                        const optionValue = isKnownTag ? tagOptionValue(tagName) : UNKNOWN_TAG_OPTION;
                        if (!selectedTagOptions.has(optionValue)) {
                            continue;
                        }
                        if (!Array.isArray(targets)) {
                            continue;
                        }
                        for (const targetId of targets) {
                            if (typeof targetId !== "string" || !stellarIdRe.test(targetId)) {
                                continue;
                            }
                            if (allowedMtlaAccounts && !allowedMtlaAccounts.has(targetId)) {
                                continue;
                            }
                            if (!nodesMap.has(targetId)) {
                                const targetContact = contactLabels[targetId] || "";
                                nodesMap.set(targetId, {
                                    id: targetId,
                                    bsnName: "",
                                    contactLabel: targetContact,
                                    name: targetContact,
                                    label: labelFromName(targetContact, targetId)
                                });
                                incomingRaw.set(targetId, 0);
                                outgoingRaw.set(targetId, 0);
                            }

                            rawLinks += 1;
                            incomingRaw.set(targetId, (incomingRaw.get(targetId) || 0) + 1);
                            outgoingRaw.set(sourceId, (outgoingRaw.get(sourceId) || 0) + 1);

                            const edgeKey = sourceId + ">" + targetId;
                            if (!edgeMap.has(edgeKey)) {
                                edgeMap.set(edgeKey, {
                                    source: sourceId,
                                    target: targetId,
                                    count: 0,
                                    tags: {}
                                });
                            }
                            const edge = edgeMap.get(edgeKey);
                            edge.count += 1;
                            edge.tags[tagName] = (edge.tags[tagName] || 0) + 1;
                        }
                    }
                }

                const nodes = [];
                let maxIncoming = 0;
                for (const node of nodesMap.values()) {
                    maxIncoming = Math.max(maxIncoming, incomingRaw.get(node.id) || 0);
                }
                for (const node of nodesMap.values()) {
                    const incoming = incomingRaw.get(node.id) || 0;
                    const outgoing = outgoingRaw.get(node.id) || 0;
                    const size = 16 + (Math.log2(incoming + 1) * 9);
                    const searchText = [
                        node.id,
                        node.name,
                        node.bsnName,
                        node.contactLabel
                    ].filter(Boolean).join(" ").toLowerCase();
                    nodes.push({
                        data: {
                            id: node.id,
                            label: node.label,
                            displayName: node.name || shortAccount(node.id),
                            bsnName: node.bsnName || "",
                            contactLabel: node.contactLabel || "",
                            searchText: searchText,
                            incoming: incoming,
                            outgoing: outgoing,
                            degreeRaw: incoming + outgoing,
                            size: Number(size.toFixed(2))
                        }
                    });
                }

                const formatTags = function (tags) {
                    return Object.entries(tags)
                        .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
                        .map(([name, count]) => name + " (" + count + ")")
                        .join(", ");
                };

                const visualEdges = [];
                const processedKeys = new Set();
                let maxEdgeWeight = 1;

                for (const [edgeKey, edge] of edgeMap.entries()) {
                    if (processedKeys.has(edgeKey)) {
                        continue;
                    }

                    const reverseKey = edge.target + ">" + edge.source;
                    const reverseEdge = edgeMap.get(reverseKey);

                    if (reverseEdge && reverseKey !== edgeKey) {
                        processedKeys.add(edgeKey);
                        processedKeys.add(reverseKey);

                        const totalWeight = edge.count + reverseEdge.count;
                        maxEdgeWeight = Math.max(maxEdgeWeight, totalWeight);

                        visualEdges.push({
                            source: edge.source,
                            target: edge.target,
                            weight: totalWeight,
                            bidirectional: true,
                            forwardCount: edge.count,
                            backwardCount: reverseEdge.count,
                            forwardTagsText: formatTags(edge.tags),
                            backwardTagsText: formatTags(reverseEdge.tags),
                            tagsText: formatTags(edge.tags) + " | " + formatTags(reverseEdge.tags)
                        });
                        continue;
                    }

                    processedKeys.add(edgeKey);
                    maxEdgeWeight = Math.max(maxEdgeWeight, edge.count);
                    visualEdges.push({
                        source: edge.source,
                        target: edge.target,
                        weight: edge.count,
                        bidirectional: false,
                        forwardCount: edge.count,
                        backwardCount: 0,
                        forwardTagsText: formatTags(edge.tags),
                        backwardTagsText: "",
                        tagsText: formatTags(edge.tags)
                    });
                }

                const edges = [];
                let edgeIndex = 0;
                for (const edge of visualEdges) {
                    const edgeWidth = 1 + (edge.weight / maxEdgeWeight) * 5;
                    edges.push({
                        data: {
                            id: "e" + edgeIndex,
                            source: edge.source,
                            target: edge.target,
                            weight: edge.weight,
                            edgeWidth: Number(edgeWidth.toFixed(2)),
                            bidirectional: edge.bidirectional ? 1 : 0,
                            sourceArrow: edge.bidirectional ? "triangle" : "none",
                            targetArrow: "triangle",
                            curveStyle: edge.bidirectional ? "straight" : "bezier",
                            forwardCount: edge.forwardCount,
                            backwardCount: edge.backwardCount,
                            forwardTagsText: edge.forwardTagsText,
                            backwardTagsText: edge.backwardTagsText,
                            tagsText: edge.tagsText
                        }
                    });
                    edgeIndex += 1;
                }

                const topIncoming = nodes
                    .map((node) => ({
                        id: node.data.id,
                        displayName: node.data.displayName,
                        incoming: node.data.incoming
                    }))
                    .sort((a, b) => b.incoming - a.incoming || a.id.localeCompare(b.id))
                    .slice(0, 10);

                return {
                    elements: nodes.concat(edges),
                    nodesCount: nodes.length,
                    edgesCount: edges.length,
                    rawLinks: rawLinks,
                    declaredAccounts: Object.keys(accounts).length,
                    filteredAccounts: nodes.length,
                    createdAt: data.createDate || "",
                    topIncoming: topIncoming
                };
            }

            function setSummaryValue(id, value) {
                const node = document.getElementById(id);
                if (node) {
                    node.textContent = String(value);
                }
            }

            function renderTopIncoming(items) {
                topIncomingList.innerHTML = "";
                for (const item of items) {
                    const li = document.createElement("li");
                    li.innerHTML =
                        "<a href=\"/accounts/" + encodeURIComponent(item.id) + "\">" +
                        escapeHtml(item.displayName) +
                        "</a>" +
                        "<span class=\"tag is-light\">" + item.incoming + "</span>";
                    topIncomingList.appendChild(li);
                }
            }

            function setStatus(text, isError) {
                statusText.textContent = text;
                statusText.classList.toggle("has-text-danger", Boolean(isError));
                statusText.classList.toggle("has-text-grey", !isError);
            }

            function hideSearchSuggestions() {
                if (!searchSuggestions) {
                    return;
                }
                searchSuggestions.classList.add("is-hidden");
                searchSuggestions.innerHTML = "";
            }

            function buildSearchIndex() {
                searchIndex = [];
                cy.nodes().forEach((node) => {
                    const id = node.id();
                    const displayName = String(node.data("displayName") || "");
                    const bsnName = String(node.data("bsnName") || "");
                    const contactLabel = String(node.data("contactLabel") || "");
                    searchIndex.push({
                        id: id,
                        displayName: displayName,
                        bsnName: bsnName,
                        contactLabel: contactLabel,
                        idUpper: id.toUpperCase(),
                        displayLower: displayName.toLowerCase(),
                        bsnLower: bsnName.toLowerCase(),
                        contactLower: contactLabel.toLowerCase(),
                        searchText: String(node.data("searchText") || "").toLowerCase()
                    });
                });
            }

            function scoreSearchItem(item, queryLower, queryUpper) {
                let score = 0;
                if (item.idUpper === queryUpper) {
                    score += 5000;
                }
                if (item.idUpper.startsWith(queryUpper)) {
                    score += 1400;
                } else if (item.idUpper.includes(queryUpper)) {
                    score += 800;
                }

                if (item.contactLower === queryLower) {
                    score += 1200;
                } else if (item.contactLower.includes(queryLower)) {
                    score += 700;
                }

                if (item.bsnLower === queryLower) {
                    score += 1100;
                } else if (item.bsnLower.includes(queryLower)) {
                    score += 600;
                }

                if (item.displayLower === queryLower) {
                    score += 900;
                } else if (item.displayLower.includes(queryLower)) {
                    score += 500;
                }

                if (score === 0 && item.searchText.includes(queryLower)) {
                    score += 300;
                }
                return score;
            }

            function findSearchMatches(queryRaw) {
                const query = String(queryRaw || "").trim();
                if (!query) {
                    return [];
                }
                const queryLower = query.toLowerCase();
                const queryUpper = query.toUpperCase();
                return searchIndex
                    .map((item) => ({
                        item: item,
                        score: scoreSearchItem(item, queryLower, queryUpper)
                    }))
                    .filter((entry) => entry.score > 0)
                    .sort((a, b) => b.score - a.score || a.item.displayName.localeCompare(b.item.displayName))
                    .slice(0, 12)
                    .map((entry) => entry.item);
            }

            function focusNodeById(accountId, options) {
                const opts = Object.assign({
                    revealIfHidden: true,
                    animate: true
                }, options || {});
                if (!cy) {
                    return false;
                }
                const node = cy.getElementById(accountId);
                if (!node || node.length === 0) {
                    return false;
                }

                if (node.hasClass("hidden")) {
                    if (!opts.revealIfHidden) {
                        return false;
                    }
                    minIncomingInput.value = "0";
                    hideIsolatedInput.checked = false;
                    applyFilters();
                    if (node.hasClass("hidden")) {
                        return false;
                    }
                }

                cy.nodes().unselect();
                cy.edges().unselect();
                node.select();
                emphasizeNode(node);
                renderNodeDetails(node);

                if (opts.animate) {
                    const zoom = Math.min(2.4, Math.max(cy.zoom(), 1.45));
                    cy.animate({
                        center: {eles: node},
                        zoom: zoom
                    }, {
                        duration: 220
                    });
                }

                return true;
            }

            function applyPinnedNodeSelection() {
                if (!pinnedNodeId) {
                    return false;
                }
                return focusNodeById(pinnedNodeId, {
                    revealIfHidden: false,
                    animate: false
                });
            }

            function renderSearchSuggestions(items) {
                if (!searchSuggestions) {
                    return;
                }
                if (!items.length) {
                    searchSuggestions.innerHTML = "<div class=\"graph-search-item-empty\">" + escapeHtml(i18n.searchNoMatches) + "</div>";
                    searchSuggestions.classList.remove("is-hidden");
                    return;
                }

                const html = items.map((item) => {
                    const aliases = [];
                    if (item.contactLabel && item.contactLabel !== item.displayName) {
                        aliases.push("book: " + item.contactLabel);
                    }
                    if (item.bsnName && item.bsnName !== item.displayName) {
                        aliases.push("bsn: " + item.bsnName);
                    }

                    const metaParts = [item.id].concat(aliases);
                    return "<div class=\"graph-search-item\" data-account-id=\"" + escapeHtml(item.id) + "\">" +
                        "<div class=\"graph-search-item-title\">" + escapeHtml(item.displayName || shortAccount(item.id)) + "</div>" +
                        "<div class=\"graph-search-item-meta\">" + escapeHtml(metaParts.join(" | ")) + "</div>" +
                        "</div>";
                }).join("");

                searchSuggestions.innerHTML = html;
                searchSuggestions.classList.remove("is-hidden");

                searchSuggestions.querySelectorAll(".graph-search-item[data-account-id]").forEach((element) => {
                    element.addEventListener("mousedown", function (event) {
                        event.preventDefault();
                        const accountId = element.getAttribute("data-account-id");
                        focusNodeById(accountId);
                        searchInput.value = element.querySelector(".graph-search-item-title").textContent || "";
                        hideSearchSuggestions();
                    });
                });
            }

            function updateSearchSuggestions() {
                if (!searchInput) {
                    return;
                }
                if (!cy) {
                    return;
                }
                const query = searchInput.value || "";
                const matches = findSearchMatches(query);
                if (!query.trim()) {
                    hideSearchSuggestions();
                    return;
                }
                renderSearchSuggestions(matches);
            }

            function assignClusters() {
                const colors = [
                    "#2d7dd2", "#f3722c", "#2a9d8f", "#e63946", "#6a4c93",
                    "#1b9aaa", "#ef476f", "#118ab2", "#ff8fab", "#588157",
                    "#8338ec", "#3a86ff", "#e76f51", "#4361ee", "#ff006e"
                ];
                const components = cy.elements().components()
                    .sort((a, b) => b.nodes().length - a.nodes().length);

                let largest = 0;
                components.forEach((component, index) => {
                    const color = colors[index % colors.length];
                    largest = Math.max(largest, component.nodes().length);
                    component.nodes().forEach((node) => {
                        node.data("cluster", index + 1);
                        node.style("background-color", color);
                    });
                });

                return {count: components.length, largest: largest};
            }

            function assignCentricDistances(centerNode) {
                const visibleNodes = cy.nodes().not(".hidden");
                const visibleEdges = cy.edges().not(".hidden");
                const distances = new Map();

                visibleNodes.forEach((node) => {
                    distances.set(node.id(), -1);
                });

                const centerId = centerNode.id();
                if (!distances.has(centerId)) {
                    return;
                }

                distances.set(centerId, 0);
                const queue = [centerId];
                let cursor = 0;
                let maxDistance = 0;

                while (cursor < queue.length) {
                    const currentId = queue[cursor++];
                    const currentDistance = distances.get(currentId);
                    const currentNode = cy.getElementById(currentId);
                    if (!currentNode || currentNode.length === 0) {
                        continue;
                    }

                    currentNode.connectedEdges().forEach((edge) => {
                        if (!visibleEdges.contains(edge)) {
                            return;
                        }
                        const sourceId = edge.source().id();
                        const targetId = edge.target().id();
                        const nextId = sourceId === currentId ? targetId : sourceId;
                        if (!distances.has(nextId) || distances.get(nextId) !== -1) {
                            return;
                        }
                        const nextDistance = currentDistance + 1;
                        distances.set(nextId, nextDistance);
                        maxDistance = Math.max(maxDistance, nextDistance);
                        queue.push(nextId);
                    });
                }

                visibleNodes.forEach((node) => {
                    const distance = distances.get(node.id());
                    node.data("centricDistance", distance);
                    if (distance === -1) {
                        node.data("centricRank", -1);
                        return;
                    }
                    node.data("centricRank", maxDistance - distance + 2);
                });
            }

            function runLayout() {
                const layoutName = layoutSelect.value || "cose";
                const visible = cy.elements().not(".hidden");

                if (centricMode && pinnedNodeId) {
                    const pinnedNode = cy.getElementById(pinnedNodeId);
                    if (pinnedNode && pinnedNode.length > 0 && !pinnedNode.hasClass("hidden")) {
                        assignCentricDistances(pinnedNode);
                        const centricLayout = visible.layout({
                            name: "concentric",
                            animate: false,
                            fit: true,
                            padding: 28,
                            minNodeSpacing: 22,
                            concentric: function (node) {
                                return Number(node.data("centricRank") || -1);
                            },
                            levelWidth: function () {
                                return 1;
                            },
                            startAngle: (-Math.PI) / 2,
                            sweep: 2 * Math.PI
                        });
                        centricLayout.on("layoutstop", function () {
                            applyPinnedNodeSelection();
                        });
                        centricLayout.run();
                        return;
                    }
                }

                const optionsByLayout = {
                    cose: {
                        name: "cose",
                        animate: false,
                        fit: true,
                        padding: 28,
                        nodeRepulsion: 220000,
                        idealEdgeLength: 85
                    },
                    concentric: {
                        name: "concentric",
                        animate: false,
                        fit: true,
                        padding: 28,
                        minNodeSpacing: 24,
                        concentric: function (node) {
                            return node.data("incoming") + node.data("outgoing");
                        },
                        levelWidth: function () {
                            return 2;
                        }
                    },
                    breadthfirst: {
                        name: "breadthfirst",
                        directed: true,
                        animate: false,
                        fit: true,
                        padding: 28,
                        spacingFactor: 1.2
                    },
                    circle: {
                        name: "circle",
                        animate: false,
                        fit: true,
                        padding: 28
                    }
                };
                const layoutOptions = optionsByLayout[layoutName] || optionsByLayout.cose;
                const layout = visible.layout(layoutOptions);
                layout.on("layoutstop", function () {
                    applyPinnedNodeSelection();
                });
                layout.run();
            }

            function applyFilters() {
                const filterOptions = getFilterOptions();
                const minIncoming = filterOptions.minIncoming;
                cy.batch(() => {
                    cy.nodes().forEach((node) => {
                        const byIncoming = node.data("incoming") < minIncoming;
                        const byIsolated = filterOptions.hideIsolated && node.data("degreeRaw") === 0;
                        node.toggleClass("hidden", byIncoming || byIsolated);
                    });
                    cy.edges().forEach((edge) => {
                        const hide = edge.source().hasClass("hidden") || edge.target().hasClass("hidden");
                        edge.toggleClass("hidden", hide);
                    });
                });

                setSummaryValue("summary-visible-nodes", cy.nodes().not(".hidden").length);
                setSummaryValue("summary-visible-edges", cy.edges().not(".hidden").length);
                clearEmphasis();
                hideTooltip();
                return applyPinnedNodeSelection();
            }

            function renderNodeDetails(node) {
                selectionDetails.classList.remove("has-text-grey");
                const nodeGraphUrl = buildNodeGraphUrl(node.id());
                selectionDetails.innerHTML =
                    "<p><strong>" + escapeHtml(node.data("displayName")) + "</strong></p>" +
                    "<p><code>" + escapeHtml(node.id()) + "</code></p>" +
                    "<p>" + escapeHtml(i18n.nodeIncoming) + ": <strong>" + node.data("incoming") + "</strong></p>" +
                    "<p>" + escapeHtml(i18n.nodeOutgoing) + ": <strong>" + node.data("outgoing") + "</strong></p>" +
                    "<p>" + escapeHtml(i18n.nodeCluster) + ": <strong>" + (node.data("cluster") || "-") + "</strong></p>" +
                    "<p><a href=\"/accounts/" + encodeURIComponent(node.id()) + "\">" + escapeHtml(i18n.nodeOpenAccount) + "</a></p>" +
                    "<p><a href=\"" + escapeHtml(nodeGraphUrl) + "\">" + escapeHtml(i18n.nodeLink) + "</a></p>";
            }

            function renderEdgeDetails(edge) {
                selectionDetails.classList.remove("has-text-grey");
                if (edge.data("bidirectional")) {
                    selectionDetails.innerHTML =
                        "<p><strong>" + escapeHtml(i18n.edgeSource) + ":</strong> <code>" + escapeHtml(edge.data("source")) + "</code></p>" +
                        "<p><strong>" + escapeHtml(i18n.edgeTarget) + ":</strong> <code>" + escapeHtml(edge.data("target")) + "</code></p>" +
                        "<p><strong>" + escapeHtml(i18n.edgeCount) + ":</strong> " + edge.data("weight") + "</p>" +
                        "<p><strong>" + escapeHtml(edge.data("source")) + "  " + escapeHtml(edge.data("target")) + ":</strong> " + edge.data("forwardCount") + "</p>" +
                        "<p>" + escapeHtml(edge.data("forwardTagsText") || "-") + "</p>" +
                        "<p><strong>" + escapeHtml(edge.data("target")) + "  " + escapeHtml(edge.data("source")) + ":</strong> " + edge.data("backwardCount") + "</p>" +
                        "<p>" + escapeHtml(edge.data("backwardTagsText") || "-") + "</p>";
                    return;
                }

                selectionDetails.innerHTML =
                    "<p><strong>" + escapeHtml(i18n.edgeSource) + ":</strong> <code>" + escapeHtml(edge.data("source")) + "</code></p>" +
                    "<p><strong>" + escapeHtml(i18n.edgeTarget) + ":</strong> <code>" + escapeHtml(edge.data("target")) + "</code></p>" +
                    "<p><strong>" + escapeHtml(i18n.edgeCount) + ":</strong> " + edge.data("weight") + "</p>" +
                    "<p><strong>" + escapeHtml(i18n.edgeTags) + ":</strong> " + escapeHtml(edge.data("tagsText") || "-") + "</p>";
            }

            function clearEmphasis() {
                cy.elements().removeClass("muted");
                cy.elements().removeClass("related-edge");
                cy.elements().removeClass("related-edge-in");
                cy.elements().removeClass("related-edge-out");
                cy.elements().removeClass("related-edge-both");
                cy.nodes().removeClass("focus-node");
            }

            function emphasizeNode(node) {
                clearEmphasis();
                cy.elements().addClass("muted");
                node.removeClass("muted");
                node.addClass("focus-node");
                node.connectedEdges().forEach((edge) => {
                    edge.removeClass("muted");
                    edge.addClass("related-edge");
                    const isBidirectional = Number(edge.data("bidirectional")) === 1;
                    const edgeSourceId = String(edge.data("source") || "");
                    const edgeTargetId = String(edge.data("target") || "");
                    const nodeId = node.id();

                    if (isBidirectional || edgeSourceId === edgeTargetId) {
                        edge.addClass("related-edge-both");
                    } else if (edgeTargetId === nodeId) {
                        edge.addClass("related-edge-in");
                    } else if (edgeSourceId === nodeId) {
                        edge.addClass("related-edge-out");
                    }
                    edge.source().removeClass("muted");
                    edge.target().removeClass("muted");
                });
            }

            function redrawGraph() {
                if (!cy || !sourceGraphData) {
                    return;
                }

                const graph = buildGraph(sourceGraphData, sourceContactLabels, sourceKnownLinks, getFilterOptions());
                cy.batch(() => {
                    cy.elements().remove();
                    cy.add(graph.elements);
                });

                buildSearchIndex();
                const clusterInfo = assignClusters();
                const pinnedSelected = applyFilters();
                runLayout();

                setSummaryValue("summary-created-at", renderDate(graph.createdAt));
                setSummaryValue("summary-total-accounts", graph.declaredAccounts);
                setSummaryValue("summary-total-nodes", graph.nodesCount);
                setSummaryValue("summary-total-links", graph.rawLinks);
                setSummaryValue("summary-pair-links", graph.edgesCount);
                setSummaryValue("summary-clusters", clusterInfo.count);
                setSummaryValue("summary-largest-cluster", clusterInfo.largest);

                renderTopIncoming(graph.topIncoming);
                if (!pinnedSelected) {
                    selectionDetails.textContent = i18n.detailsEmpty;
                    selectionDetails.classList.add("has-text-grey");
                }
                hideSearchSuggestions();
                setStatus("", false);
            }

            function attachCyEventHandlers() {
                cy.on("tap", "node", function (event) {
                    emphasizeNode(event.target);
                    renderNodeDetails(event.target);
                });
                cy.on("tap", "edge", function (event) {
                    clearEmphasis();
                    renderEdgeDetails(event.target);
                });
                cy.on("tap", function (event) {
                    if (event.target === cy) {
                        clearEmphasis();
                        hideTooltip();
                        selectionDetails.textContent = i18n.detailsEmpty;
                        selectionDetails.classList.add("has-text-grey");
                    }
                });
                cy.on("mouseover", "node", function (event) {
                    showTooltip(event.target, event.renderedPosition);
                });
                cy.on("mousemove", "node", function (event) {
                    showTooltip(event.target, event.renderedPosition);
                });
                cy.on("mouseout", "node", function () {
                    hideTooltip();
                });
                cy.on("zoom pan", function () {
                    hideTooltip();
                });
            }

            async function initGraph() {
                setStatus(i18n.loading, false);

                try {
                    if (onlyMtlaInput && queryOnlyMtla) {
                        onlyMtlaInput.checked = true;
                    }

                    const [data, contactLabels, knownLinks] = await Promise.all([
                        fetchGraphJson(),
                        fetchContactLabels(),
                        fetchKnownLinks()
                    ]);
                    sourceGraphData = data;
                    sourceContactLabels = contactLabels;
                    sourceKnownLinks = knownLinks || {};

                    initializeTagTypeOptions(sourceGraphData.accounts || {}, sourceKnownLinks);

                    cy = cytoscape({
                        container: document.getElementById("cy"),
                        elements: [],
                        wheelSensitivity: 0.18,
                        style: [
                            {
                                selector: "node",
                                style: {
                                    "label": "data(label)",
                                    "width": "data(size)",
                                    "height": "data(size)",
                                    "font-size": 8,
                                    "min-zoomed-font-size": 6,
                                    "text-wrap": "wrap",
                                    "text-max-width": 80,
                                    "text-valign": "center",
                                    "text-halign": "center",
                                    "text-background-color": "#ffffff",
                                    "text-background-opacity": 0.55,
                                    "text-background-padding": 1.5,
                                    "color": "#1f2937",
                                    "border-width": 1,
                                    "border-color": "#ffffff",
                                    "background-color": "#3a86ff"
                                }
                            },
                            {
                                selector: "edge",
                                style: {
                                    "curve-style": "data(curveStyle)",
                                    "source-arrow-shape": "data(sourceArrow)",
                                    "target-arrow-shape": "data(targetArrow)",
                                    "arrow-scale": 0.8,
                                    "line-color": "#94a3b8",
                                    "source-arrow-color": "#94a3b8",
                                    "target-arrow-color": "#94a3b8",
                                    "opacity": 0.55,
                                    "width": "data(edgeWidth)"
                                }
                            },
                            {
                                selector: "node:selected",
                                style: {
                                    "border-width": 3,
                                    "border-color": "#111827",
                                    "z-index": 999
                                }
                            },
                            {
                                selector: "edge:selected",
                                style: {
                                    "line-color": "#ef233c",
                                    "source-arrow-color": "#ef233c",
                                    "target-arrow-color": "#ef233c",
                                    "opacity": 0.9,
                                    "z-index": 998
                                }
                            },
                            {
                                selector: ".related-edge",
                                style: {
                                    "opacity": 0.95,
                                    "width": "mapData(weight, 1, 20, 2, 8)",
                                    "z-index": 997
                                }
                            },
                            {
                                selector: ".related-edge-in",
                                style: {
                                    "line-color": "#3A86FF",
                                    "source-arrow-color": "#3A86FF",
                                    "target-arrow-color": "#3A86FF"
                                }
                            },
                            {
                                selector: ".related-edge-out",
                                style: {
                                    "line-color": "#FB5607",
                                    "source-arrow-color": "#FB5607",
                                    "target-arrow-color": "#FB5607"
                                }
                            },
                            {
                                selector: ".related-edge-both",
                                style: {
                                    "line-color": "#8338EC",
                                    "source-arrow-color": "#8338EC",
                                    "target-arrow-color": "#8338EC"
                                }
                            },
                            {
                                selector: ".focus-node",
                                style: {
                                    "border-width": 3,
                                    "border-color": "#ef233c",
                                    "z-index": 999
                                }
                            },
                            {
                                selector: ".muted",
                                style: {
                                    "opacity": 0.12
                                }
                            },
                            {
                                selector: ".hidden",
                                style: {
                                    "display": "none"
                                }
                            }
                        ]
                    });

                    attachCyEventHandlers();
                    layoutRun.addEventListener("click", runLayout);
                    if (filtersApplyButton) {
                        filtersApplyButton.addEventListener("click", redrawGraph);
                    }

                    redrawGraph();
                } catch (error) {
                    console.error(error);
                    hideTooltip();
                    setStatus(i18n.loadError, true);
                }
            }

            if (searchInput) {
                searchInput.addEventListener("input", updateSearchSuggestions);
                searchInput.addEventListener("focus", updateSearchSuggestions);
                searchInput.addEventListener("keydown", function (event) {
                    if (event.key === "Escape") {
                        hideSearchSuggestions();
                        return;
                    }
                    if (event.key !== "Enter") {
                        return;
                    }
                    const matches = findSearchMatches(searchInput.value || "");
                    if (!matches.length) {
                        return;
                    }
                    event.preventDefault();
                    focusNodeById(matches[0].id);
                    searchInput.value = matches[0].displayName || shortAccount(matches[0].id);
                    hideSearchSuggestions();
                });

                document.addEventListener("click", function (event) {
                    if (!searchSuggestions || !searchInput) {
                        return;
                    }
                    const target = event.target;
                    if (target === searchInput) {
                        return;
                    }
                    if (searchSuggestions.contains(target)) {
                        return;
                    }
                    hideSearchSuggestions();
                });
            }

            if (tagFilterActionLinks.length) {
                tagFilterActionLinks.forEach(function (link) {
                    link.addEventListener("click", function (event) {
                        event.preventDefault();
                        const action = link.getAttribute("data-tag-filter-action") || "";
                        applyTagFilterPreset(action);
                    });
                });
            }

            initGraph();
        })();
    </script>
{% endblock %}
